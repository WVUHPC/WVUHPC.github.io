.. _qs-command-line:

Command Line Interface
======================

The interaction with a HPC cluster happens most of the time using a Command Line Interface (CLI). One the cluster all your interaction is controlled by a program called a *shell*. You identify that you are in *shell* when you see what is called a *prompt*, a set of characters that indicate that the *shell* is ready to receive instructions to operate.

To issue a command to the shell you type a command, eventually followed for a few arguments. When you end typing the full command you type the ``ENTER`` key, the command is executed and if the command is programmed to produce screen output it will appear on your terminal as it executes. Once the command is terminated you get a new *prompt* indicating that the shell is ready for new commands.

The CLI interface is a powerful way to interact with a remote computer.

1. It takes little resources on the remote machine allowing the machine to serve tens, hundreds and in some cases even thousands of concurrent users.

2. The *shell* is far more than command reader and executioner, it is actually a complete programming language. You can create complex sets of instructions by doing what is called *Shell Programming* actually the ability to do shell programming is what we use in this document to differentiate a basic user from an advanced user.

3. Despite of the learning curve being steeper, the CLI give you far more control on the machine, so as you become more comfortable using it you will be able to do things than on a Graphical User Interface are simply cumbersome.

Using a CLI is probably the biggest obstacle than beginners has to overcome before start taking advantage of a HPC cluster. Here we will offer a short straight to the point introduction to the bare minimals of managing files and folders on the *shell*.

Files and Folders
-----------------

Operating Systems from UNIX legacy, Linux and MacOS being the most prominent examples, uses the idea of *folders* and *files* to organize the data on their storage device. Differently from Windows, on UNIX there is not such idea of Drives ``C:`` or ``D:`` or letters for CD Drives or USB Keys. In UNIX every piece of data on any storage device is logically located in some place of a *filesystem tree*. Thing about the *filesystem tree* where the lowest level is called *the root folder* and is indicated by ``/``. From ``/`` you will see branches like ``/bin``, ``/lib`` and many others, those are folders. Inside each folder there are potentially more folders and files. The tree structure as a metaphor for storing data is very powerful and in the case of UNIX system that data structure is deeply exploited in UNIX systems, even hardware devices such as sound outputs, hard drives receive a file-like entry on the rooted tree.
When you insert a USB drive, Modern Linux distributions and MacOS will *mount* it automatically, meaning that it will receive a location on the tree, in the case of Linux, the mounting point is usually somewhere inside */media/*, in MacOS the mounting point is */Volumes*.

In the particular case of your interaction with the HPC cluster there are two important folders that you should be aware of. They are so important that they receive special variables to tell you what they are.

The *echo* and *cat* commands
-----------------------------

Your fist command will show you what those locations are. Execute::

  $> echo $HOME
  /users/<username>
  $> echo $SCRATCH
  /scratch/<username>

The first command to learn is ``echo``. The command above uses ``echo`` to show the contents of two shell variables ``$HOME`` and ``$SCRATCH``. Shell variables are ways to store information in such a way that the shell can use it when needed. Each user on the cluster receives appropriated values for those variables.

Lets explore a bit more the usage of ``echo``. Enter this command line and execute ``ENTER``::

  $> echo "I am learning UNIX Commands"
  I am learning UNIX Commands


The shell is actually able to do basic arithmetical operations, execute this command::

  $> echo $((23+45*2))
  113

Notice that as customary in mathematics products take precedence over addition. That is called the PEMDAS order of operations, ie "Parentheses, Exponents, Multiplication and Division, and Addition and Subtraction". Check your understanding of the PEMDAS rule with this command::

  $> echo $(((1+2**3*(4+5)-7)/2+9))
  42

Notice that the exponential operation is expressed with the ``**`` operator.
The usage of ``echo`` is important, otherwise, if you execute the command without ``echo`` the shell will do the operation and will try to execute a command called ``42`` that does not exists on the system. Try by yourself::

  $> $ $(((1+2**3*(4+5)-7)/2+9))
  -bash: 42: command not found

As you have seen before, when you execute a command on the terminal in most cases you see the output printed on the screen.
The next thing to learn is how to redirect the output of a command into a file.
This will be very important later to submit jobs and control where and how the output is produced. Execute the following command::

  $> echo "I am learning UNIX Commands" > report.log

With the character ``>`` redirects the output from ``echo`` into a file called *report.log*. No output is printed on the screen. If the file does not exist it will be created. If the file exists previously, the file is erased and only the new contents are stored.

To check that the file actually contains the line produced by echo, execute::

  $> cat report.log
  I am learning UNIX Commands

The cat (concatenate) command displays the contents of one or several files. In the case of multiple files the files are printed in the order they are described in the command line, concatenating the output so the name of the command.

You can even use a nice trick to write small text on a file. Execute the following command, followed by the text that you want to write, sat the end execute ``Ctrl-D`` (``^D``), the *Control Key* followed by the ``D`` key.
I am annotating below the location where ``^D`` should be executed::

  $> cat > report.log
  I am learning UNIX Commands^D
  $> cat report.log
  I am learning UNIX Commands

In fact there are hundreds of commands, most of them with a variety of options that change the behavior of the original command. You can feel bewildered t first by the large number of existing commands, but in fact most of the time you will be using a very little number of them. Learning those will speed up your learning curve.

Folder commands
---------------

As we mention before, UNIX organizes data in storage devices as a tree.
The commands ``pwd``, ``cd`` and ``mkdir`` will allow you to know where you are, move your location on the tree and create new folders. Later we will see how to move folders from one location on the tree to another.

The first command is ``pwd``. Just execute the command on the terminal::

  $> $ pwd
  /users/<username>

It is very important at all times to know where in the tree you are. Doing research usually involves dealing with important amount of data, exploring several parameters or physical conditions. Organize properly all the data in meaningful folders is very important to research endeavors.

When you log into a cluster, by default you are located on your ``$HOME`` folder. That is why most likely the command ``pwd`` will return that location in a first instance.

The next command is ``cd``. This command is used to *change directory*. Directory is another name for *folder*.
The term *directory* is also widely used.
At least in UNIX the terms *directory* and *folder* are exchangeable.
Other Desktop Operating Systems like Windows and MacOS have the concept of *smart folders* or *virtual folders*, where the *folder* that you see on screen has not correlation with a directory in the filesystem.
In those cases the distinction is relevant.

There is another important folder defined in our clusters, its called the scratch folder and each user has its own. The location of the folder is stored in the variable ``$SCRATCH``. Notice that this is an internal convection and is not observed in other HPC clusters.

Use the next command to go to that folder::

  $> cd $SCRATCH
  $> pwd
  /scratch/<username>

Notice that the location is different now, if you are using this account for the first time you will not have files on this folder.
It is time to learn another command to list the contents of a *folder*, execute::

  $> ls
  $>

Assuming that you are using your HPC account for the first time, you will not have anything on your ``$SCRATCH`` folder.
This is a good opportunity to start creating one folder there and change your location inside, execute::

  $> mkdir test_folder
  $> cd test_folder

We have use two new commands here, ``mkdir`` allow you to create folders in places where you are authorized to do so. For example your ``$HOME`` and ``$SCRATCH`` folders. Try this command::

  $> mkdir /test_folder
  mkdir: cannot create directory `/test_folder': Permission denied

There is an important difference between ``test_folder`` and ``/test_folder``.
The former is a location in your current working directory (CWD), the later is a location starting on the root directory ``/``. A normal user has no rights to create folders on that directory so ``mkdir`` will fail and a error message will be shown on your screen.

The name of the folder is ``test_folder``, notice the underscore between *test* and *folder*. In UNIX, there is no restriction having files or directories with spaces but using them become a nuisance on the command line. If you want to create the folder with spaces from the command line, here are the options::

  $> mkdir "test folder with spaces"
  $> mkdir another\ test\ folder\ with\ spaces

In any case you have to type extra characters to prevent the command line application of consider those spaces as separators for several arguments in your command. Try executing the following::

  $> mkdir another folder with spaces
  $> ls
  another  another folder with spaces  folder  spaces  test_folder  test folder with spaces  with

Maybe is not clear what is happening here. There is an option for ``ls`` that present the contents of a directory::

    $>ls -l
    total 0
    drwxr-xr-x 2 myname mygroup 512 Nov  2 15:44 another
    drwxr-xr-x 2 myname mygroup 512 Nov  2 15:45 another folder with spaces
    drwxr-xr-x 2 myname mygroup 512 Nov  2 15:44 folder
    drwxr-xr-x 2 myname mygroup 512 Nov  2 15:44 spaces
    drwxr-xr-x 2 myname mygroup 512 Nov  2 15:45 test_folder
    drwxr-xr-x 2 myname mygroup 512 Nov  2 15:45 test folder with spaces
    drwxr-xr-x 2 myname mygroup 512 Nov  2 15:44 with

It should be clear, now what happens when the spaces are not contained in quotes ``"test folder with spaces"`` or escaped as ``another\ folder\ with\ spaces``.
This is the perfect opportunity to learn how to delete empty folders. Execute::

  $> rmdir another
  $> rmdir folder spaces with

You can delete one or several folders, but all those folders must be empty.
If those folders contain files or more folders, the command will fail and error message will be displayed.
